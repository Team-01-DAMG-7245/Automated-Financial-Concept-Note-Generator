The starting point for a Monte Carlo simulation is the construction of a Brownian motion sample path
(or Wiener path). Such paths are built from a set of independent Gaussian variates, using either
standard discretization, Brownian-bridge construction, or principal components construction.

Both standard discretization and Brownian-bridge construction share the same variance and,
therefore, the same resulting convergence when used with the MonteCarloMethod using pseudo
random numbers. However, the performance differs between the two when the MonteCarloMethod
option "quasi" is introduced, with faster convergence for the "brownian-bridge" construction
option and the fastest convergence for the "principal-components" construction option.

Data Types: string | char

Z — Direct specification of dependent random noise process used to generate the Brownian
motion vector
Correlated Gaussian variates generated by Correlation of rvm or roughbergomi model (default) |
numeric array

Direct specification of the dependent random noise process used to generate the Brownian motion
vector (Wiener process) that drives the simulation. This argument is specified as a function or as an
(NPeriods ⨉ NSteps)-by-NBrowns-by-NTrials three-dimensional array of dependent random
variates.

Data Types: double

StorePaths — Flag that indicates how the output array Paths is stored and returned
True (default) | logical with values True or False

Flag that indicates how the output array Paths is stored and returned, specified as a scalar logical
flag with a value of True or False.

•
If StorePaths is True (the default value) or is unspecified, simByEuler returns Paths as a
three-dimensional time series array.

•
If StorePaths is False (logical 0), simByEuler returns the Paths output array as an empty
matrix.

Data Types: logical

Processes — Sequence of end-of-period processes or state vector adjustments
[] (default) | function | cell array of functions

Sequence of end-of-period processes or state vector adjustments, specified as a function or cell array
of functions of the form

Xt = P(t, Xt)

The simByEuler function runs processing functions at each observation period. They must accept
the current observation time t, and the current state vector Xt, and return a state vector that may be
an adjustment to the input state.

If you specify more than one processing function, simByEuler invokes the functions in the order in
which they appear in the cell array. You can use this argument to specify boundary conditions,
prevent negative prices, accumulate statistics, and plot graphs.

Data Types: cell | function

15
Functions

15-334
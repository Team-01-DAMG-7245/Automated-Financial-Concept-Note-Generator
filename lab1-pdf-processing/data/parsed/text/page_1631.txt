Xt = P(t, Xt)

The simByEuler function runs processing functions at each interpolation time. The functions must
accept the current interpolation time t, and the current state vector Xt and return a state vector that
can be an adjustment to the input state.

If you specify more than one processing function, simByEuler invokes the functions in the order in
which they appear in the cell array. You can use this argument to specify boundary conditions,
prevent negative prices, accumulate statistics, and plot graphs.

The end-of-period Processes argument allows you to terminate a given trial early. At the end of each
time step, simByEuler tests the state vector Xt for an all-NaN condition. Thus, to signal an early
termination of a given trial, all elements of the state vector Xt must be NaN. This test enables you to
define a Processes function to signal early termination of a trial, and offers significant performance
benefits in some situations (for example, pricing down-and-out barrier options).

Data Types: cell | function

Output Arguments

Paths — Simulated paths of correlated state variables
array

Simulated paths of correlated state variables, returned as an (NPeriods + 1)-by-NVars-by-
NTrials three-dimensional time series array.

For a given trial, each row of Paths is the transpose of the state vector Xt at time t. When
StorePaths is set to false, simByEuler returns Paths as an empty matrix.

Times — Observation times associated with simulated paths
column vector

Observation times associated with the simulated paths, returned as an (NPeriods + 1)-by-1
column vector. Each element of Times is associated with the corresponding row of Paths.

Z — Dependent random variates for generating Brownian motion vector
array

Dependent random variates used to generate the Brownian motion vector (Wiener processes) that
drive the simulation, returned as an (NPeriods ⨉ NSteps)-by-NBrowns-by-NTrials three-
dimensional time-series array.

N — Dependent random variates used for generating jump counting process vector
array

Dependent random variates for generating the jump counting process vector, returned as an
(NPeriods ⨉ NSteps)-by-NJumps-by-NTrials three-dimensional time-series array.

More About

Euler Simulation

Euler simulation approximates the solution of an SDE by discretizing the continuous-time process
into discrete time steps.

simByEuler

15-325